<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Morphing - Liquid Flow</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: "Yu Gothic", "Meiryo", sans-serif; }
        canvas { display: block; outline: none; }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        .glass-panel {
            background: rgba(10, 10, 10, 0.80);
            backdrop-filter: blur(16px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: -10px 0 30px rgba(0, 0, 0, 0.8);
        }

        input[type="text"] {
            background: rgba(0,0,0,0.5);
            border: 1px solid #333;
            color: white;
            transition: border-color 0.3s;
        }
        input[type="text"]:focus {
            border-color: cyan;
            outline: none;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #22d3ee;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.8);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- UI Container -->
    <div class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between">

        <!-- Header -->
        <header class="p-6 w-full flex justify-between items-start">
            <div>
                <h1 class="text-3xl font-bold tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 filter drop-shadow-[0_0_8px_rgba(0,255,255,0.5)]">
                    FLUID MORPH
                </h1>
                <p class="text-[10px] text-gray-400 tracking-[0.3em] mt-1 uppercase">Dynamic Particle System v3.1</p>
            </div>

            <!-- Settings Toggle -->
            <button id="toggleSettings" class="pointer-events-auto group flex items-center gap-2 px-4 py-2 rounded-full border border-white/10 bg-white/5 hover:bg-white/10 backdrop-blur-sm transition-all">
                <div class="w-2 h-2 rounded-full bg-cyan-400 group-hover:animate-pulse"></div>
                <span class="text-xs font-bold text-gray-300 group-hover:text-white tracking-wider">SETTINGS</span>
            </button>
        </header>

        <!-- Footer Controls -->
        <div class="p-8 flex flex-col items-center pointer-events-none">
            <div class="relative group pointer-events-auto">
                <div class="absolute -inset-1 bg-gradient-to-r from-cyan-500 to-purple-600 rounded-full blur opacity-25 group-hover:opacity-75 transition duration-500"></div>
                <button id="morphBtn" class="relative px-12 py-4 bg-black rounded-full leading-none flex items-center divide-x divide-gray-600 border border-gray-800 hover:border-gray-600 transition-all active:scale-95">
                    <span class="pr-4 text-gray-100 font-bold tracking-widest text-sm">TRANSFORM</span>
                    <span class="pl-4 text-cyan-400 text-xs font-mono group-hover:text-purple-400 transition-colors">
                        Click to Morph
                    </span>
                </button>
            </div>

            <div class="mt-4 flex gap-6 text-[10px] font-mono text-gray-500 uppercase tracking-widest">
                <span class="flex items-center gap-1"><div class="w-1 h-1 bg-cyan-500 rounded-full"></div> <span id="particleCount">0</span> PTS</span>
                <span class="flex items-center gap-1"><div class="w-1 h-1 bg-purple-500 rounded-full"></div> ZOOM: SCROLL</span>
            </div>
        </div>
    </div>

    <!-- Settings Panel (Right Side) -->
    <div id="settingsPanel" class="absolute top-0 right-0 h-full w-80 glass-panel transform translate-x-full transition-transform duration-500 ease-[cubic-bezier(0.23,1,0.32,1)] z-20 flex flex-col pointer-events-auto">
        <div class="p-8 flex-1 overflow-y-auto">
            <div class="flex justify-between items-center mb-8">
                <h2 class="text-white font-bold tracking-widest text-xs uppercase border-l-2 border-cyan-500 pl-3">Control Panel</h2>
                <button id="closeSettings" class="text-gray-500 hover:text-white transition-colors p-2">✕</button>
            </div>

            <!-- Visual Parameters -->
            <div class="mb-8 space-y-6">
                <h3 class="text-[10px] text-gray-400 font-bold uppercase tracking-widest mb-4">Visual Dynamics</h3>

                <!-- Density (Removed) -->

                <!-- Size -->
                <div>
                    <div class="flex justify-between text-[10px] text-gray-400 mb-2 uppercase font-mono">
                        <span>Particle Size</span>
                        <span id="val-size" class="text-cyan-400">1.5</span>
                    </div>
                    <input type="range" id="param-size" min="0.1" max="4.0" step="0.1" value="1.5" class="w-full accent-cyan-400">
                </div>

                <!-- Turbulence (Flow Strength) -->
                <div>
                    <div class="flex justify-between text-[10px] text-gray-400 mb-2 uppercase font-mono">
                        <span>Flow Strength</span>
                        <span id="val-explosion" class="text-purple-400">0.8</span>
                    </div>
                    <input type="range" id="param-explosion" min="0" max="3.0" step="0.1" value="0.8" class="w-full accent-purple-500">
                </div>

                <!-- Speed -->
                <div>
                    <div class="flex justify-between text-[10px] text-gray-400 mb-2 uppercase font-mono">
                        <span>Duration</span>
                        <span id="val-speed" class="text-green-400">2.5s</span>
                    </div>
                    <input type="range" id="param-speed" min="0.5" max="5.0" step="0.1" value="2.5" class="w-full accent-green-500">
                </div>
            </div>

            <!-- Inputs -->
            <div class="space-y-6 pt-6 border-t border-white/10">
                <!-- Obj 1 -->
                <div>
                    <label class="text-[10px] text-cyan-400 font-bold uppercase tracking-widest mb-2 block">State 01</label>
                    <input type="text" id="text1" value="現実" class="w-full px-3 py-3 rounded bg-black/40 border border-white/10 focus:border-cyan-500/50 text-sm font-medium placeholder-gray-700">

                    <div class="mt-2 relative group">
                        <input type="file" id="file1" accept="image/*" class="hidden">
                        <label for="file1" class="block w-full py-2 border border-dashed border-gray-700 rounded text-center text-[10px] text-gray-500 hover:text-cyan-400 hover:border-cyan-500/30 cursor-pointer transition-all">
                            <span id="fileLabel1">UPLOAD IMAGE</span>
                        </label>
                        <button id="clearFile1" class="hidden absolute top-0 right-0 h-full px-2 text-red-400 hover:bg-red-500/10 text-xs">✕</button>
                    </div>
                </div>

                <!-- Obj 2 -->
                <div>
                    <label class="text-[10px] text-purple-400 font-bold uppercase tracking-widest mb-2 block">State 02</label>
                    <input type="text" id="text2" value="幻想" class="w-full px-3 py-3 rounded bg-black/40 border border-white/10 focus:border-purple-500/50 text-sm font-medium placeholder-gray-700">

                    <div class="mt-2 relative group">
                        <input type="file" id="file2" accept="image/*" class="hidden">
                        <label for="file2" class="block w-full py-2 border border-dashed border-gray-700 rounded text-center text-[10px] text-gray-500 hover:text-purple-400 hover:border-purple-500/30 cursor-pointer transition-all">
                            <span id="fileLabel2">UPLOAD IMAGE</span>
                        </label>
                        <button id="clearFile2" class="hidden absolute top-0 right-0 h-full px-2 text-red-400 hover:bg-red-500/10 text-xs">✕</button>
                    </div>
                </div>
            </div>

            <button id="applyBtn" class="mt-8 w-full py-4 bg-white text-black font-bold text-xs tracking-widest hover:bg-gray-200 transition-colors">
                REGENERATE SYSTEM
            </button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- ADVANCED FLUID SHADERS -->
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float uTime;
        uniform float uProgress;
        uniform float uSizeScale;
        uniform float uExplosion; // Using this as "Flow Strength"

        attribute vec3 aPositionStart;
        attribute vec3 aPositionEnd;
        attribute vec3 aColorStart;
        attribute vec3 aColorEnd;
        attribute float aSize;

        varying vec3 vColor;
        varying float vAlpha;

        // --- Simplex Noise 3D Implementation ---
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);

            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );

            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;

            i = mod289(i);
            vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;

            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );

            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);

            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );

            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));

            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);

            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;

            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        // --- Curl Noise Approximation (Using offsets of noise) ---
        vec3 curlNoise(vec3 p) {
            float e = 0.1;
            float n1 = snoise(p + vec3(e, 0.0, 0.0));
            float n2 = snoise(p + vec3(-e, 0.0, 0.0));
            float n3 = snoise(p + vec3(0.0, e, 0.0));
            float n4 = snoise(p + vec3(0.0, -e, 0.0));
            float n5 = snoise(p + vec3(0.0, 0.0, e));
            float n6 = snoise(p + vec3(0.0, 0.0, -e));

            float x = n3 - n4 - (n5 - n6);
            float y = n5 - n6 - (n1 - n2);
            float z = n1 - n2 - (n3 - n4);

            return normalize(vec3(x, y, z));
        }

        void main() {
            float t = uProgress;

            // Cubic-bezier like ease for smoother start/stop
            float easeT = t < 0.5 ? 4.0 * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;

            vec3 posStart = aPositionStart;
            vec3 posEnd = aPositionEnd;

            // 1. Base Interpolation
            vec3 finalPos = mix(posStart, posEnd, easeT);

            // 2. IDLE MOTION (Breathing) - Always active
            // Makes particles float slowly even when stationary
            float idleSpeed = 0.1; // Slowed down from 0.3
            float idleAmp = 0.8;   // Reduced from 3.0 to make it very subtle
            vec3 idleOffset = curlNoise(finalPos * 0.02 + uTime * idleSpeed) * idleAmp;
            finalPos += idleOffset;

            // 3. TRANSITION FLOW (Fluidity) - Active during morph
            // Peak intensity at t=0.5
            float transitionIntensity = sin(t * 3.14159);

            // Create a large swirling vector field
            vec3 flowField = curlNoise(finalPos * 0.01 + uTime * 0.5);

            // Apply flow strength (uExplosion)
            // Instead of just exploding out, we move ALONG the noise field
            // giving it a liquid/smoke feel
            finalPos += flowField * transitionIntensity * 80.0 * uExplosion;

            // Also add a slight random jitter for "dust" texture
            finalPos.x += sin(uTime * 10.0 + aPositionStart.y) * 0.2;

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            // Size logic:
            // Make them slightly larger when they are moving fast (motion blur fake)
            float motionSize = 1.0 + transitionIntensity * 0.5;
            gl_PointSize = aSize * uSizeScale * motionSize * (300.0 / -mvPosition.z);

            // Color interpolation
            vColor = mix(aColorStart, aColorEnd, easeT);

            // Alpha logic: Fade out slightly during chaotic movement to look ghost-like
            vAlpha = 1.0;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
            // Soft particle texture (Gaussian-ish)
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);

            // Softer falloff for that "HomePod Mini" fuzzy look
            // Instead of hard cut at 0.5, we do a smooth fade
            if(dist > 0.5) discard;

            // Exponential falloff for glow center
            float alpha = exp(-dist * 5.0); // Sharp center

            // Add a softer outer rim
            float rim = smoothstep(0.5, 0.0, dist) * 0.3;

            float finalAlpha = (alpha + rim) * vAlpha;

            // Boosting saturation
            gl_FragColor = vec4(vColor, finalAlpha);
        }
    </script>

    <script>
        // --- Global State ---
        const state = {
            obj1: { type: 'text', content: '現実', imageSrc: null },
            obj2: { type: 'text', content: '幻想', imageSrc: null },
            isState1: true,
            isAnimating: false,
            densityStep: 1, // FIXED: High Density by default (step 1)
            sizeScale: 1.5,
            explosion: 0.8,
            speed: 2.5
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 150;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        // Interaction State
        const mouse = { x: 0, y: 0 };
        const targetRotation = { x: 0, y: 0 };

        // ZOOM LOGIC
        let targetZoom = 150;
        let currentZoom = 150;

        document.addEventListener('wheel', (e) => {
            const zoomSpeed = 0.2;
            targetZoom += e.deltaY * zoomSpeed;
            targetZoom = Math.max(20, Math.min(500, targetZoom));
        }, { passive: true });

        // --- Particle Generation Logic ---
        function generateData(config, gradientType, stepSize) {
            return new Promise((resolve) => {
                const width = 500;
                const height = 500;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = width;
                canvas.height = height;

                const processData = () => {
                    const imageData = ctx.getImageData(0, 0, width, height);
                    const data = imageData.data;
                    const coords = [];
                    const colors = [];

                    for (let y = 0; y < height; y += stepSize) {
                        for (let x = 0; x < width; x += stepSize) {
                            const i = (y * width + x) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const a = data[i + 3];

                            if (a > 30) {
                                const px = (x - width / 2) * 0.8;
                                const py = -(y - height / 2) * 0.8;
                                const pz = (Math.random() - 0.5) * 20;
                                coords.push(px, py, pz);
                                colors.push(r / 255, g / 255, b / 255);
                            }
                        }
                    }
                    resolve({ coords, colors });
                };

                if (config.type === 'image' && config.imageSrc) {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        const scale = Math.min(width / img.width, height / img.height);
                        const w = img.width * scale;
                        const h = img.height * scale;
                        const ox = (width - w) / 2;
                        const oy = (height - h) / 2;
                        ctx.drawImage(img, ox, oy, w, h);
                        processData();
                    };
                    img.onerror = () => {
                        drawText();
                        processData();
                    };
                    img.src = config.imageSrc;
                } else {
                    drawText();
                    processData();
                }

                function drawText() {
                    const gradient = ctx.createLinearGradient(0, 0, width, 0);
                    if (gradientType === 'cyan') {
                        gradient.addColorStop(0, '#00ffff');
                        gradient.addColorStop(0.5, '#0088ff');
                        gradient.addColorStop(1, '#8800ff');
                    } else {
                        gradient.addColorStop(0, '#ff00cc');
                        gradient.addColorStop(0.5, '#ff4400');
                        gradient.addColorStop(1, '#ffcc00');
                    }

                    ctx.fillStyle = gradient;
                    ctx.font = '900 130px "Inter", "Yu Gothic", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = "rgba(255,255,255,0.5)";
                    ctx.shadowBlur = 20;
                    ctx.fillText(config.content, width / 2, height / 2);
                }
            });
        }

        let particles;
        let material;

        async function initParticles() {
            if (particles) {
                particleGroup.remove(particles);
                particles.geometry.dispose();
            }

            // Density is fixed to state.densityStep which is now 1
            const step = state.densityStep;

            const [data1, data2] = await Promise.all([
                generateData(state.obj1, 'cyan', step),
                generateData(state.obj2, 'pink', step)
            ]);

            const count = Math.max(data1.coords.length, data2.coords.length) / 3;
            document.getElementById('particleCount').innerText = count.toLocaleString();

            const maxCount = count;
            const geometry = new THREE.BufferGeometry();

            const posStart = new Float32Array(maxCount * 3);
            const posEnd = new Float32Array(maxCount * 3);
            const colorStart = new Float32Array(maxCount * 3);
            const colorEnd = new Float32Array(maxCount * 3);
            const sizes = new Float32Array(maxCount);

            const fill = (target, source, isPos) => {
                for (let i = 0; i < maxCount; i++) {
                    const i3 = i * 3;
                    if (i3 < source.length) {
                        target[i3] = source[i3];
                        target[i3 + 1] = source[i3 + 1];
                        target[i3 + 2] = source[i3 + 2];
                    } else {
                        if (isPos) {
                            target[i3] = (Math.random() - 0.5) * 600;
                            target[i3 + 1] = (Math.random() - 0.5) * 600;
                            target[i3 + 2] = (Math.random() - 0.5) * 600;
                        } else {
                            target[i3] = 0; target[i3+1] = 0; target[i3+2] = 0;
                        }
                    }
                }
            };

            fill(posStart, data1.coords, true);
            fill(posEnd, data2.coords, true);
            fill(colorStart, data1.colors, false);
            fill(colorEnd, data2.colors, false);

            for (let i = 0; i < maxCount; i++) {
                sizes[i] = Math.random() * 1.5 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posStart, 3));
            geometry.setAttribute('aPositionStart', new THREE.BufferAttribute(posStart, 3));
            geometry.setAttribute('aPositionEnd', new THREE.BufferAttribute(posEnd, 3));
            geometry.setAttribute('aColorStart', new THREE.BufferAttribute(colorStart, 3));
            geometry.setAttribute('aColorEnd', new THREE.BufferAttribute(colorEnd, 3));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

            material = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                uniforms: {
                    uTime: { value: 0 },
                    uProgress: { value: state.isState1 ? 0 : 1 },
                    uSizeScale: { value: state.sizeScale },
                    uExplosion: { value: state.explosion }
                },
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            particleGroup.add(particles);

            state.isAnimating = false;
        }

        initParticles();

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Smooth Zoom
            currentZoom += (targetZoom - currentZoom) * 0.1;
            camera.position.z = currentZoom;

            if (material) {
                material.uniforms.uTime.value = time;
                material.uniforms.uSizeScale.value = state.sizeScale;
                material.uniforms.uExplosion.value = state.explosion;
            }

            // Mouse Parallax
            particleGroup.rotation.x += (targetRotation.x - particleGroup.rotation.x) * 0.03;
            particleGroup.rotation.y += (targetRotation.y - particleGroup.rotation.y) * 0.03;

            renderer.render(scene, camera);
        }
        animate();

        // --- Event Listeners ---

        document.addEventListener('mousemove', (e) => {
            const x = (e.clientX / window.innerWidth) * 2 - 1;
            const y = (e.clientY / window.innerHeight) * 2 - 1;

            targetRotation.x = y * 0.15;
            targetRotation.y = x * 0.15;
        });

        document.addEventListener('mouseleave', () => {
            targetRotation.x = 0;
            targetRotation.y = 0;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('morphBtn').addEventListener('click', () => {
            if (state.isAnimating || !material) return;
            state.isAnimating = true;
            state.isState1 = !state.isState1;

            const target = state.isState1 ? 0 : 1;

            gsap.to(material.uniforms.uProgress, {
                value: target,
                duration: state.speed,
                ease: "power2.inOut",
                onComplete: () => {
                    state.isAnimating = false;
                }
            });
        });

        // --- UI Logic ---
        const settingsPanel = document.getElementById('settingsPanel');
        const toggleSettingsBtn = document.getElementById('toggleSettings');
        const closeSettingsBtn = document.getElementById('closeSettings');

        function toggleSettings() {
            settingsPanel.classList.toggle('translate-x-full');
        }
        toggleSettingsBtn.addEventListener('click', toggleSettings);
        closeSettingsBtn.addEventListener('click', toggleSettings);

        // --- Inputs ---
        // Density input listeners removed

        const sizeInput = document.getElementById('param-size');
        const sizeVal = document.getElementById('val-size');
        sizeInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.sizeScale = val;
            sizeVal.innerText = val.toFixed(1);
        });

        const expInput = document.getElementById('param-explosion');
        const expVal = document.getElementById('val-explosion');
        expInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.explosion = val;
            expVal.innerText = val.toFixed(1);
        });

        const speedInput = document.getElementById('param-speed');
        const speedVal = document.getElementById('val-speed');

        speedInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.speed = val;
            speedVal.innerText = val.toFixed(1) + 's';
        });

        function setupFileInput(fileInputId, labelId, clearBtnId, objKey) {
            const fileInput = document.getElementById(fileInputId);
            const label = document.getElementById(labelId);
            const clearBtn = document.getElementById(clearBtnId);

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        state[objKey].type = 'image';
                        state[objKey].imageSrc = event.target.result;
                        label.innerText = file.name;
                        label.classList.add('text-cyan-400');
                        clearBtn.classList.remove('hidden');
                    };
                    reader.readAsDataURL(file);
                }
            });

            clearBtn.addEventListener('click', (e) => {
                e.preventDefault();
                fileInput.value = '';
                state[objKey].type = 'text';
                state[objKey].imageSrc = null;
                label.innerText = 'UPLOAD IMAGE';
                label.classList.remove('text-cyan-400');
                clearBtn.classList.add('hidden');
            });
        }

        setupFileInput('file1', 'fileLabel1', 'clearFile1', 'obj1');
        setupFileInput('file2', 'fileLabel2', 'clearFile2', 'obj2');

        document.getElementById('applyBtn').addEventListener('click', () => {
            state.obj1.content = document.getElementById('text1').value || "現実";
            state.obj2.content = document.getElementById('text2').value || "幻想";

            // Density is always 1 now, no need to read input
            state.densityStep = 1;

            if (!state.obj1.imageSrc) state.obj1.type = 'text';
            if (!state.obj2.imageSrc) state.obj2.type = 'text';

            initParticles();
            toggleSettings();
        });

    </script>
</body>
</html>