<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Instant Camera App</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden; /* Prevent scrolling when dragging */
        touch-action: none;
        user-select: none; /* 全局禁止文字选择 */
        -webkit-user-select: none;
      }

      /* Custom Font for the Polaroid Text */
      .handwritten {
        font-family: "Permanent Marker", cursive;
      }

      /* Flash Animation */
      @keyframes flash-animation {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      .flash-active {
        animation: flash-animation 0.8s ease-out forwards;
      }

      /* Photo Ejection Animation - Stops halfway */
      @keyframes eject-photo-partial {
        0% {
          transform: translateY(100%);
        }
        100% {
          transform: translateY(-60%);
        }
      }
      .ejecting {
        animation: eject-photo-partial 0.8s cubic-bezier(0.25, 1, 0.5, 1)
          forwards;
      }

      /* Developing Effect (显影效果) - 2s */
      @keyframes develop-image {
        0% {
          filter: blur(8px) grayscale(1) brightness(1.8) contrast(0.8);
          opacity: 0.9;
        }
        50% {
          filter: blur(4px) grayscale(0.6) brightness(1.2);
        }
        100% {
          filter: blur(0) grayscale(0) brightness(1) contrast(1);
          opacity: 1;
        }
      }
      /* 只有带有 developing 类的元素才会执行显影动画 */
      .developing img {
        animation: develop-image 2s ease-in-out forwards;
      }

      /* Dragging & Selection Styles */
      .draggable {
        cursor: grab;
        position: absolute;
        /* 关键修改：确保 box-shadow 和 transform 始终有过渡动画，除非被 .is-dragging 覆盖 */
        transition: box-shadow 0.4s cubic-bezier(0.25, 0.8, 0.25, 1),
          transform 0.3s ease;
        touch-action: none;
        will-change: transform, box-shadow;
      }

      /* 只有真正拖拽时才应用这个类 */
      .draggable.is-dragging {
        cursor: grabbing;
        z-index: 1000 !important;
        /* 拖拽时稍微回正，并保持放大 */
        transform: scale(1.05) rotate(0deg) !important;
        /* 拖拽时阴影更深 */
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.3);
        /* 拖拽时禁用位置过渡（跟手），但保留阴影过渡会更自然一点，或者也禁用以防卡顿 */
        transition: none;
      }

      /* 选中状态：大阴影 + 轻微上浮 */
      .selected-photo {
        z-index: 50;
        transform: scale(1.02); /* 稍微变大 */
        /* 更大、更柔和的阴影 */
        box-shadow: 0 35px 60px -15px rgba(0, 0, 0, 0.4);
      }

      /* Photo style inside printer */
      .in-printer {
        z-index: 0;
        cursor: grab;
      }
      .in-printer:hover {
        transform: translateY(-65%) !important;
      }
    </style>
  </head>
  <body
    class="bg-gray-100 h-screen w-screen relative flex flex-col md:flex-row overflow-hidden"
  >
    <!-- Flash Overlay -->
    <div
      id="flash-overlay"
      class="fixed inset-0 bg-white pointer-events-none opacity-0 z-[100]"
    ></div>

    <!-- Header / Controls -->
    <div class="absolute top-4 right-4 z-50 flex gap-2">
      <button
        id="delete-btn"
        class="bg-white border-2 border-red-500 text-red-500 px-6 py-2 rounded-full font-bold hover:bg-red-50 transition shadow-lg cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed select-none hidden md:block"
      >
        DELETE
      </button>
      <button
        id="download-btn"
        class="bg-white border-2 border-black px-6 py-2 rounded-full font-bold hover:bg-gray-100 transition shadow-lg cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed select-none"
      >
        DOWNLOAD
      </button>
    </div>

    <!-- Left Side: Camera Area -->
    <div
      class="w-full h-1/2 md:w-1/2 md:h-full flex items-center justify-center relative p-4"
      id="camera-zone"
    >
      <!-- Camera Container -->
      <div
        class="relative w-[320px] md:w-[450px] transition-all duration-500"
        id="camera-container"
      >
        <!-- The Ejecting Photo Slot (Behind Camera) -->
        <!-- Adjusted height for taller photos -->
        <div
          class="absolute top-0 left-1/2 -translate-x-1/2 w-[160px] h-[240px] z-0"
          id="printer-slot"
        >
          <!-- Photos will be appended here -->
        </div>

        <!-- Camera Image -->
        <img
          src="https://wgzhao.me/images/img/X5CczwV7I?w=800&fm=png"
          alt="Instant Camera"
          class="w-full relative z-20 pointer-events-none drop-shadow-2xl select-none"
          id="camera-img"
        />

        <!-- Webcam Feed (Lens) -->
        <div
          id="lens-wrapper"
          class="absolute z-30 overflow-hidden rounded-full bg-[#111] border-4 border-gray-800/50 shadow-inner"
        >
          <video
            id="webcam"
            autoplay
            playsinline
            muted
            class="w-full h-full object-cover transform scale-x-[-1]"
          ></video>
        </div>

        <!-- Shutter Button Area -->
        <div
          id="shutter-btn"
          class="absolute z-40 rounded-full cursor-pointer hover:bg-white/10 active:bg-white/20 transition"
          title="Take Photo"
        ></div>

        <!-- Indicator Light -->
        <div
          id="status-light"
          class="absolute top-[18%] right-[28%] w-3 h-3 rounded-full bg-red-500 z-30 shadow-[0_0_10px_red] transition-colors duration-300"
        ></div>
      </div>
    </div>

    <!-- Right Side: Photo Gallery / Drop Zone -->
    <div
      class="w-full h-1/2 md:w-1/2 md:h-full bg-[radial-gradient(#e5e7eb_1px,transparent_1px)] [background-size:16px_16px] relative overflow-hidden"
      id="gallery-zone"
    >
      <div
        class="absolute inset-0 pointer-events-none flex items-center justify-center text-gray-300 font-bold text-4xl uppercase tracking-widest select-none opacity-50"
      >
        Drop Here
      </div>
    </div>

    <!-- Hidden Canvas for rendering download image -->
    <canvas id="render-canvas" class="hidden"></canvas>

    <script>
      // --- CONFIGURATION & CALIBRATION ---
      const CAMERA_CONFIG = {
        // 镜头位置
        lensTop: 50.5,
        lensLeft: 52.5,
        lensSize: 20.5,

        // 快门按钮位置
        btnTop: 36,
        btnLeft: 15,
        btnSize: 10,
      };

      // --- STATE ---
      let selectedPhotoId = null;
      let dragItem = null;
      let dragOffset = { x: 0, y: 0 };
      let startPos = { x: 0, y: 0 }; // 用于检测是否真的移动了
      let isDragging = false; // 显式标记拖拽状态
      let zIndexCounter = 100;
      let audioContext = null;

      // --- DOM ELEMENTS ---
      const video = document.getElementById("webcam");
      const lensWrapper = document.getElementById("lens-wrapper");
      const shutterBtn = document.getElementById("shutter-btn");
      const flashOverlay = document.getElementById("flash-overlay");
      const printerSlot = document.getElementById("printer-slot");
      const galleryZone = document.getElementById("gallery-zone");
      const statusLight = document.getElementById("status-light");
      const downloadBtn = document.getElementById("download-btn");
      const deleteBtn = document.getElementById("delete-btn");

      // --- INITIALIZATION ---
      async function initCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          video.srcObject = stream;
          statusLight.classList.remove("bg-red-500", "shadow-[0_0_10px_red]");
          statusLight.classList.add("bg-green-500", "shadow-[0_0_10px_green]");
        } catch (err) {
          console.warn("Camera fallback mode", err);
          video.style.display = "none";
          lensWrapper.style.backgroundColor = "#1a1a1a";
        }

        // Init Audio Context on user interaction to bypass autoplay policy
        document.addEventListener("click", initAudioContext, { once: true });
        document.addEventListener("keydown", initAudioContext, { once: true });

        updateControls();
      }

      function initAudioContext() {
        if (!audioContext) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (AudioContext) {
            audioContext = new AudioContext();
            // Play a tiny silent buffer to warm up the engine
            const buffer = audioContext.createBuffer(1, 1, 22050);
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);
          }
        } else if (audioContext.state === "suspended") {
          audioContext.resume();
        }
      }

      function applyCalibration() {
        lensWrapper.style.top = `${CAMERA_CONFIG.lensTop}%`;
        lensWrapper.style.left = `${CAMERA_CONFIG.lensLeft}%`;
        lensWrapper.style.width = `${CAMERA_CONFIG.lensSize}%`;
        lensWrapper.style.height = `${CAMERA_CONFIG.lensSize}%`;
        lensWrapper.style.aspectRatio = "1/1";

        shutterBtn.style.top = `${CAMERA_CONFIG.btnTop}%`;
        shutterBtn.style.left = `${CAMERA_CONFIG.btnLeft}%`;
        shutterBtn.style.width = `${CAMERA_CONFIG.btnSize}%`;
        shutterBtn.style.aspectRatio = "1/1";
      }

      // --- SOUND EFFECT (FIXED & LOUDER) ---
      function playShutterSound() {
        // Ensure context exists and is running
        initAudioContext();

        if (!audioContext) return;

        try {
          const t = audioContext.currentTime;

          // 1. Mechanical Click (Low Thud)
          const oscLow = audioContext.createOscillator();
          const gainLow = audioContext.createGain();
          oscLow.type = "square"; // Square wave for sharper mechanical sound
          oscLow.frequency.setValueAtTime(150, t);
          oscLow.frequency.exponentialRampToValueAtTime(40, t + 0.1);

          gainLow.gain.setValueAtTime(0.5, t);
          gainLow.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

          oscLow.connect(gainLow);
          gainLow.connect(audioContext.destination);
          oscLow.start(t);
          oscLow.stop(t + 0.1);

          // 2. Shutter Release (High Snap)
          const oscHigh = audioContext.createOscillator();
          const gainHigh = audioContext.createGain();
          oscHigh.type = "sawtooth";
          oscHigh.frequency.setValueAtTime(800, t);
          oscHigh.frequency.exponentialRampToValueAtTime(100, t + 0.15);

          gainHigh.gain.setValueAtTime(0.3, t);
          gainHigh.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

          oscHigh.connect(gainHigh);
          gainHigh.connect(audioContext.destination);
          oscHigh.start(t);
          oscHigh.stop(t + 0.15);

          // 3. Motor Whir / Noise (The "Shhh" sound)
          const bufferSize = audioContext.sampleRate * 0.15;
          const buffer = audioContext.createBuffer(
            1,
            bufferSize,
            audioContext.sampleRate
          );
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
          }

          const noise = audioContext.createBufferSource();
          noise.buffer = buffer;
          const noiseGain = audioContext.createGain();
          // Louder noise
          noiseGain.gain.setValueAtTime(0.8, t);
          noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

          noise.connect(noiseGain);
          noiseGain.connect(audioContext.destination);
          noise.start(t);
        } catch (e) {
          console.error("Audio Error:", e);
        }
      }

      // --- PHOTO CAPTURE ---
      shutterBtn.addEventListener("click", takePhoto);

      function takePhoto() {
        playShutterSound();

        // Flash
        flashOverlay.classList.remove("flash-active");
        void flashOverlay.offsetWidth;
        flashOverlay.classList.add("flash-active");

        const canvas = document.createElement("canvas");
        const targetWidth = 600;
        const targetHeight = 800;

        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext("2d");

        const isCameraActive =
          video.style.display !== "none" &&
          video.srcObject &&
          video.srcObject.active;

        if (isCameraActive) {
          try {
            const videoRatio = video.videoWidth / video.videoHeight;
            const targetRatio = targetWidth / targetHeight;

            let renderWidth, renderHeight, startX, startY;

            if (videoRatio > targetRatio) {
              renderHeight = video.videoHeight;
              renderWidth = video.videoHeight * targetRatio;
              startX = (video.videoWidth - renderWidth) / 2;
              startY = 0;
            } else {
              renderWidth = video.videoWidth;
              renderHeight = video.videoWidth / targetRatio;
              startX = 0;
              startY = (video.videoHeight - renderHeight) / 2;
            }

            ctx.translate(targetWidth, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(
              video,
              startX,
              startY,
              renderWidth,
              renderHeight,
              0,
              0,
              targetWidth,
              targetHeight
            );
          } catch (e) {
            drawFallbackImage(ctx, targetWidth, targetHeight);
          }
        } else {
          drawFallbackImage(ctx, targetWidth, targetHeight);
        }

        const imgDataUrl = canvas.toDataURL("image/png");
        const timestamp = new Date().toLocaleString("en-US", {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          hour12: true,
        });

        createPolaroid(imgDataUrl, timestamp);
      }

      function drawFallbackImage(ctx, w, h) {
        ctx.fillStyle = "#111111";
        ctx.fillRect(0, 0, w, h);
        for (let i = 0; i < 80000; i++) {
          const x = Math.random() * w;
          const y = Math.random() * h;
          const brightness = Math.random() * 20 + 10;
          ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, 0.1)`;
          ctx.fillRect(x, y, 2, 2);
        }
        const maxDim = Math.max(w, h);
        const gradient = ctx.createRadialGradient(
          w / 2,
          h / 2,
          maxDim * 0.3,
          w / 2,
          h / 2,
          maxDim * 0.8
        );
        gradient.addColorStop(0, "transparent");
        gradient.addColorStop(1, "rgba(0,0,0,0.8)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);
      }

      function createPolaroid(imgUrl, dateText) {
        const id = Date.now();

        const polaroid = document.createElement("div");
        polaroid.className =
          "absolute bg-[#fdfdfd] shadow-lg p-3 flex flex-col items-center justify-start in-printer developing draggable"; // Add draggable base class immediately
        polaroid.style.width = "160px";
        polaroid.style.height = "240px";
        polaroid.style.paddingBottom = "30px";
        polaroid.id = `photo-${id}`;

        const img = document.createElement("img");
        img.src = imgUrl;
        img.className =
          "w-full aspect-[3/4] object-cover bg-gray-900 pointer-events-none select-none";
        img.draggable = false;

        const label = document.createElement("div");
        label.className =
          "handwritten text-gray-600 text-xs mt-3 text-center w-full leading-tight pointer-events-none select-none";
        label.innerText = dateText;

        polaroid.appendChild(img);
        polaroid.appendChild(label);

        printerSlot.appendChild(polaroid);

        setTimeout(() => {
          polaroid.classList.add("ejecting");
        }, 200);

        // Interaction
        polaroid.addEventListener("mousedown", startDrag);
        polaroid.addEventListener("touchstart", startDrag, { passive: false });
        polaroid.addEventListener("click", (e) => {
          e.stopPropagation();
          // Click handled in startDrag/stopDrag logic for better consistency
        });
      }

      // --- DRAG & DROP (IMPROVED) ---
      function startDrag(e) {
        if (e.type === "touchstart") e.preventDefault();

        // Ensure audio context is ready on first interaction
        initAudioContext();

        dragItem = e.currentTarget;
        isDragging = false; // Reset dragging flag

        // Get start coordinates to calculate delta later
        const clientX =
          e.type === "touchstart" ? e.touches[0].clientX : e.clientX;
        const clientY =
          e.type === "touchstart" ? e.touches[0].clientY : e.clientY;
        startPos = { x: clientX, y: clientY };

        const rect = dragItem.getBoundingClientRect();
        dragOffset.x = clientX - rect.left;
        dragOffset.y = clientY - rect.top;

        // Immediately select on MouseDown (Animation starts now)
        // Because we haven't added 'is-dragging' yet, the transition is active!
        selectPhoto(dragItem);
        zIndexCounter++;
        dragItem.style.zIndex = zIndexCounter;

        document.addEventListener("mousemove", onDrag);
        document.addEventListener("mouseup", stopDrag);
        document.addEventListener("touchmove", onDrag, { passive: false });
        document.addEventListener("touchend", stopDrag);
      }

      function onDrag(e) {
        if (!dragItem) return;
        if (e.type === "touchmove") e.preventDefault();

        const clientX =
          e.type === "touchmove" ? e.touches[0].clientX : e.clientX;
        const clientY =
          e.type === "touchmove" ? e.touches[0].clientY : e.clientY;

        // Check if moved enough to consider it a "drag"
        if (!isDragging) {
          const dx = Math.abs(clientX - startPos.x);
          const dy = Math.abs(clientY - startPos.y);
          if (dx > 3 || dy > 3) {
            isDragging = true;
            // Now we are actually dragging, add the class that removes transitions for snapping
            dragItem.classList.add("is-dragging");

            // If dragging out of printer, setup
            if (dragItem.parentNode !== document.body) {
              const rect = dragItem.getBoundingClientRect();
              dragItem.style.left = `${rect.left}px`;
              dragItem.style.top = `${rect.top}px`;
              dragItem.style.transform = "none";
              dragItem.classList.remove("ejecting", "in-printer", "developing");
              document.body.appendChild(dragItem);
            }
          }
        }

        if (isDragging) {
          const newX = clientX - dragOffset.x;
          const newY = clientY - dragOffset.y;
          dragItem.style.left = `${newX}px`;
          dragItem.style.top = `${newY}px`;
        }
      }

      function stopDrag(e) {
        if (!dragItem) return;

        dragItem.classList.remove("is-dragging");

        if (isDragging) {
          // Drop logic
          const galleryRect = galleryZone.getBoundingClientRect();
          const itemRect = dragItem.getBoundingClientRect();
          const itemCenter = {
            x: itemRect.left + itemRect.width / 2,
            y: itemRect.top + itemRect.height / 2,
          };

          if (itemCenter.x > galleryRect.left) {
            const randomRot = Math.random() * 8 - 4;
            dragItem.style.transform = `rotate(${randomRot}deg)`;
          }
        }
        // If !isDragging, it was just a click, selection already handled in startDrag

        dragItem = null;
        document.removeEventListener("mousemove", onDrag);
        document.removeEventListener("mouseup", stopDrag);
        document.removeEventListener("touchmove", onDrag);
        document.removeEventListener("touchend", stopDrag);
      }

      // --- SELECTION & DELETE ---
      function selectPhoto(el) {
        document.querySelectorAll(".selected-photo").forEach((p) => {
          p.classList.remove("selected-photo");
        });

        el.classList.add("selected-photo");
        selectedPhotoId = el.id;
        updateControls();
      }

      function deselectAll() {
        document
          .querySelectorAll(".selected-photo")
          .forEach((p) => p.classList.remove("selected-photo"));
        selectedPhotoId = null;
        updateControls();
      }

      function updateControls() {
        const hasSelection = !!selectedPhotoId;
        downloadBtn.disabled = !hasSelection;
        deleteBtn.disabled = !hasSelection;

        if (hasSelection) {
          deleteBtn.classList.remove("hidden");
        } else {
          // On mobile we might want to always show but disabled, or hide.
          // Let's keep opacity control for disabled state
        }
      }

      function deleteSelectedPhoto() {
        if (selectedPhotoId) {
          const el = document.getElementById(selectedPhotoId);
          if (el) {
            // Animate deletion?
            el.style.transition = "transform 0.2s, opacity 0.2s";
            el.style.transform = "scale(0.5)";
            el.style.opacity = "0";
            setTimeout(() => el.remove(), 200);
          }
          deselectAll();
        }
      }

      // Global Click to Deselect
      document.addEventListener("mousedown", (e) => {
        // If clicked on background (body or gallery), deselect
        // Check if clicked element is NOT a photo and NOT a control button
        const isPhoto = e.target.closest(".draggable");
        const isControl = e.target.closest("button");

        if (!isPhoto && !isControl) {
          deselectAll();
        }
      });

      // Keyboard Delete
      document.addEventListener("keydown", (e) => {
        if (e.key === "Delete" || e.key === "Backspace") {
          deleteSelectedPhoto();
        }
      });

      // Delete Button
      deleteBtn.addEventListener("click", deleteSelectedPhoto);

      // --- DOWNLOAD ---
      downloadBtn.addEventListener("click", () => {
        if (!selectedPhotoId) return;
        const el = document.getElementById(selectedPhotoId);
        if (!el) return;
        downloadPolaroid(el);
      });

      function downloadPolaroid(element) {
        const canvas = document.getElementById("render-canvas");
        const ctx = canvas.getContext("2d");
        const img = element.querySelector("img");
        const text = element.innerText;

        const cardWidth = 600;
        const cardHeight = 860;
        const padding = 40;

        canvas.width = cardWidth;
        canvas.height = cardHeight;

        ctx.fillStyle = "#fdfdfd";
        ctx.fillRect(0, 0, cardWidth, cardHeight);

        const imgWidth = cardWidth - 40 - padding * 2;
        const imgHeight = imgWidth * (4 / 3);
        ctx.drawImage(img, 20 + padding, 20 + padding, imgWidth, imgHeight);

        ctx.fillStyle = "#333333";
        ctx.font = '40px "Permanent Marker", cursive';
        ctx.textAlign = "center";
        ctx.fillText(text, cardWidth / 2, cardHeight - 60);

        const link = document.createElement("a");
        link.download = `polaroid-${Date.now()}.png`;
        link.href = canvas.toDataURL("image/png");
        link.click();
      }

      // Start
      applyCalibration();
      initCamera();
      window.addEventListener("resize", applyCalibration);
    </script>
  </body>
</html>
