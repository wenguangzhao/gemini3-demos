<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>森のちいさなへび - Forest Snake</title>

    <!-- 字体 -->
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Zen+Maru+Gothic:wght@500;700&display=swap" rel="stylesheet">

    <!-- Tailwind CSS (Stable v3.4 via CDN for reliability) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- GSAP Animation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'pixel': ['DotGothic16', 'sans-serif'],
                        'round': ['Zen Maru Gothic', 'sans-serif'],
                    },
                    colors: {
                        wood: {
                            light: '#e0a060',
                            DEFAULT: '#855028',
                            dark: '#5c3618',
                        },
                        paper: '#fffae3',
                    },
                    animation: {
                        'float': 'float 6s ease-in-out infinite',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        }
                    }
                }
            }
        }
    </script>

    <style>
        /* 全局样式与自定义特效 */
        body {
            background-color: #1a1a1a;
            background-image:
                radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                radial-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px, 20px 20px;
            background-position: 0 0, 10px 10px;
            overflow: hidden;
            touch-action: none; /* 禁止移动端默认滚动 */
        }

        canvas {
            image-rendering: pixelated; /* 保持像素清晰 */
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
        }

        /* 扫描线特效 - 更柔和 */
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.05) 50%,
                rgba(0,0,0,0.05)
            );
            background-size: 100% 4px;
            pointer-events: none;
        }

        /* 晕影 */
        .vignette {
            background: radial-gradient(circle, transparent 60%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
        }

        /* 玻璃拟态 UI */
        .glass-panel {
            background: rgba(255, 253, 235, 0.9);
            backdrop-filter: blur(8px);
            border: 4px solid #855028;
            box-shadow:
                inset 0 0 0 2px #e0a060,
                0 10px 20px rgba(0,0,0,0.2);
        }

        .pixel-btn {
            position: relative;
            transition: all 0.1s;
            box-shadow: 0 6px 0 #4a7a16;
        }
        .pixel-btn:active {
            transform: translateY(6px);
            box-shadow: 0 0 0 #4a7a16;
        }

        /* 隐藏滚动条 */
        ::-webkit-scrollbar { display: none; }
    </style>
</head>
<body class="h-screen w-screen flex items-center justify-center font-pixel text-wood-dark select-none">

    <!-- Main Game Container -->
    <div class="relative w-full max-w-2xl aspect-[3/4] md:aspect-[4/5] lg:h-[90vh] lg:w-auto lg:aspect-[3/4] flex flex-col items-center">

        <!-- Decorative Background Elements -->
        <div class="absolute -z-10 top-0 left-0 w-full h-full bg-[#2a2a2a] rounded-xl shadow-2xl border-4 border-wood-dark overflow-hidden">
            <!-- Wood Texture CSS Pattern -->
            <div class="absolute inset-0 opacity-20" style="background-image: linear-gradient(45deg, #000 25%, transparent 25%, transparent 75%, #000 75%, #000), linear-gradient(45deg, #000 25%, transparent 25%, transparent 75%, #000 75%, #000); background-size: 20px 20px; background-position: 0 0, 10px 10px;"></div>
        </div>

        <!-- Game Header UI -->
        <header class="w-[95%] mt-4 glass-panel rounded-lg p-3 flex justify-between items-center z-20 relative animate-float">
            <div class="flex items-center gap-3">
                <div class="bg-white/50 p-2 rounded border-2 border-wood-light">
                    <span class="text-2xl leading-none block transform hover:scale-110 transition-transform">❤</span>
                </div>
                <div class="flex flex-col">
                    <span class="text-xs text-wood opacity-80">季節</span>
                    <span id="season-display" class="text-xl font-bold text-[#b32828]">春</span>
                </div>
            </div>

            <div class="flex items-center gap-4">
                <div class="text-right">
                    <div class="text-xs text-wood opacity-80">売上</div>
                    <div id="score-display" class="text-2xl font-bold tabular-nums">0</div>
                </div>
                <div class="w-10 h-10 bg-wood-dark rounded-full border-4 border-[#e0a060] flex items-center justify-center text-white shadow-inner">
                    <span class="text-lg">G</span>
                </div>
            </div>
        </header>

        <!-- Canvas Area -->
        <div class="relative flex-grow w-[90%] my-4 rounded-lg overflow-hidden border-4 border-wood-dark shadow-[inset_0_0_20px_rgba(0,0,0,0.5)] bg-[#111] group cursor-pointer">
            <canvas id="gameCanvas" class="w-full h-full object-contain"></canvas>

            <!-- Visual Overlays -->
            <div class="absolute inset-0 scanlines z-10 opacity-30"></div>
            <div class="absolute inset-0 vignette z-10"></div>
            <div id="flash-overlay" class="absolute inset-0 bg-white opacity-0 pointer-events-none z-20"></div>

            <!-- Night Filter -->
            <div id="night-filter" class="absolute inset-0 bg-[#001a33] opacity-0 mix-blend-multiply pointer-events-none z-0 transition-opacity duration-[5000ms]"></div>

            <!-- Start Screen -->
            <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/60 backdrop-blur-sm z-30 transition-opacity duration-500">
                <div class="glass-panel p-8 rounded-xl flex flex-col items-center gap-4 transform hover:scale-105 transition-transform duration-300">
                    <h1 class="text-4xl md:text-5xl font-bold text-[#b32828] drop-shadow-md tracking-widest mb-2 text-center">森の<br><span class="text-2xl text-wood-dark">ちいさなへび</span></h1>
                    <div class="flex gap-2 mb-4">
                        <div class="w-3 h-3 rounded-full bg-[#69C346] animate-bounce" style="animation-delay: 0s"></div>
                        <div class="w-3 h-3 rounded-full bg-[#E6C658] animate-bounce" style="animation-delay: 0.1s"></div>
                        <div class="w-3 h-3 rounded-full bg-[#D98636] animate-bounce" style="animation-delay: 0.2s"></div>
                    </div>
                    <p class="text-center text-sm opacity-80 font-round mb-2">
                        矢印キー または タップで操作
                    </p>
                    <button id="start-btn" class="pixel-btn bg-[#7fc928] hover:bg-[#8fe032] text-white text-xl px-8 py-3 rounded font-bold border-b-4 border-[#4a7a16]">
                        はじめる
                    </button>
                </div>
            </div>

            <!-- Game Over Screen -->
            <div id="game-over-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/70 backdrop-blur-md z-30 opacity-0 pointer-events-none transition-opacity duration-500">
                <div class="glass-panel p-8 rounded-xl flex flex-col items-center gap-4 text-center transform scale-90 transition-transform duration-300" id="go-panel">
                    <h2 class="text-3xl font-bold text-[#5c3618]">気絶しました…</h2>
                    <p class="text-sm opacity-70 font-round">本日の収穫</p>
                    <div class="text-5xl font-bold text-[#b32828] my-2 drop-shadow-sm" id="final-score">0</div>
                    <div class="text-xs text-wood-dark mb-4">自己ベスト: <span id="best-score">0</span></div>
                    <button id="restart-btn" class="pixel-btn bg-[#e0a060] hover:bg-[#f0b070] text-white text-xl px-8 py-3 rounded font-bold border-b-4 border-[#855028]">
                        もう一度
                    </button>
                </div>
            </div>
        </div>

        <!-- Mobile Controls Hints -->
        <div class="md:hidden text-white/30 text-xs mb-2 font-round">
            画面の上下左右をタップして移動
        </div>
    </div>

<script>
/**
 * Star Valley Snake V2 - Refined Edition
 * Uses GSAP for smooth UI animations and Canvas for performant rendering
 */

// --- Configuration ---
const GRID_SIZE = 20;
const BASE_RESOLUTION = 600;
const TILE_SIZE = BASE_RESOLUTION / GRID_SIZE;

const COLORS = {
    spring: { bg: '#56a838', light: '#69C346', dark: '#4a912e', particle: '#ffcce6' }, // Green & Pink
    summer: { bg: '#e6c658', light: '#f0d26e', dark: '#d1b040', particle: '#fff4bd' }, // Yellow
    fall:   { bg: '#d98636', light: '#e69342', dark: '#bf702a', particle: '#d95763' }, // Orange & Red
    winter: { bg: '#a8d1e3', light: '#bae0f0', dark: '#96c0d1', particle: '#ffffff' }, // Blue & White
    snake:  { body: '#88C936', head: '#a3e635', blush: '#ff9999' },
    ui:     { text: '#5c3618' }
};

const CROPS = [
    { type: 'parsnip', color: '#F2D9BA', leaf: '#69C346' },
    { type: 'strawberry', color: '#ff4d4d', leaf: '#4a912e' }, // Summer
    { type: 'pumpkin', color: '#ff7b00', leaf: '#3E8923' },    // Fall
    { type: 'crystal', color: '#ccf2ff', leaf: '#ffffff' }     // Winter
];

// Data structure for Seasons to handle Display Name (JP) vs Logic Key (EN)
const SEASONS_INFO = [
    { name: '春', key: 'spring' },
    { name: '夏', key: 'summer' },
    { name: '秋', key: 'fall' },
    { name: '冬', key: 'winter' }
];

// --- State Management ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let state = {
    grid: [],
    snake: [], // Array of {x, y, displayX, displayY, scale}
    dir: { x: 0, y: -1 },
    nextDir: { x: 0, y: -1 },
    food: null,
    score: 0,
    highScore: localStorage.getItem('svs_highscore') || 0,
    seasonIdx: 0,
    itemsToNextSeason: 5,
    isPlaying: false,
    lastTime: 0,
    moveTimer: 0,
    moveInterval: 140, // ms per tick
    particles: [],
    dayTime: 0, // 0-1 cycle
    gameTime: 0
};

// Resize logic
function resize() {
    // Internal resolution fixed for pixel look
    canvas.width = BASE_RESOLUTION;
    canvas.height = BASE_RESOLUTION;
}
window.addEventListener('resize', resize);
resize();

// --- Game Engine ---

function initGame() {
    state.snake = [
        createSnakeNode(10, 12),
        createSnakeNode(10, 13),
        createSnakeNode(10, 14)
    ];
    state.dir = { x: 0, y: -1 };
    state.nextDir = { x: 0, y: -1 };
    state.score = 0;
    state.seasonIdx = 0;
    state.itemsToNextSeason = 5;
    state.isPlaying = true;
    state.particles = [];
    state.dayTime = 0.2; // Start in morning

    spawnFood();
    updateUI();

    // Hide screens
    gsap.to('#start-screen', { opacity: 0, duration: 0.5, onComplete: () => {
        document.getElementById('start-screen').style.display = 'none';
    }});
    gsap.to('#game-over-screen', { opacity: 0, duration: 0.3, pointerEvents: 'none' });

    // Reset loop
    state.lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function createSnakeNode(x, y) {
    return { x, y, dx: x * TILE_SIZE, dy: y * TILE_SIZE, scale: 1 };
}

function spawnFood() {
    let valid = false;
    while (!valid) {
        const fx = Math.floor(Math.random() * GRID_SIZE);
        const fy = Math.floor(Math.random() * GRID_SIZE);

        // Check collision with snake
        const onSnake = state.snake.some(s => s.x === fx && s.y === fy);
        if (!onSnake) {
            state.food = {
                x: fx,
                y: fy,
                // Food depends on season
                typeIdx: state.seasonIdx,
                scale: 0
            };
            // Spawn animation
            gsap.to(state.food, { scale: 1, duration: 0.6, ease: "elastic.out(1, 0.5)" });
            valid = true;
        }
    }
}

// --- Input Handling ---
document.addEventListener('keydown', e => {
    if (!state.isPlaying) return;
    const k = e.key;
    const d = state.dir;

    if ((k === 'ArrowUp' || k === 'w') && d.y === 0) state.nextDir = { x: 0, y: -1 };
    if ((k === 'ArrowDown' || k === 's') && d.y === 0) state.nextDir = { x: 0, y: 1 };
    if ((k === 'ArrowLeft' || k === 'a') && d.x === 0) state.nextDir = { x: -1, y: 0 };
    if ((k === 'ArrowRight' || k === 'd') && d.x === 0) state.nextDir = { x: 1, y: 0 };
});

// Touch handling
canvas.addEventListener('pointerdown', e => {
    if (!state.isPlaying) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;

    // Simple quadrant detection based on center
    const dx = x - 0.5;
    const dy = y - 0.5;

    if (Math.abs(dx) > Math.abs(dy)) {
        // Horizontal
        if (dx > 0 && state.dir.x === 0) state.nextDir = { x: 1, y: 0 };
        if (dx < 0 && state.dir.x === 0) state.nextDir = { x: -1, y: 0 };
    } else {
        // Vertical
        if (dy > 0 && state.dir.y === 0) state.nextDir = { x: 0, y: 1 };
        if (dy < 0 && state.dir.y === 0) state.nextDir = { x: 0, y: -1 };
    }
});

// --- Logic Loop ---
function update(dt) {
    state.moveTimer += dt;
    state.gameTime += dt / 1000;
    state.dayTime += 0.0002; // Slowly advance time

    // Night cycle
    const cycle = Math.sin(state.dayTime); // -1 to 1
    const darkness = Math.max(0, -cycle * 0.6); // Only dark half of cycle
    document.getElementById('night-filter').style.opacity = darkness;

    if (state.moveTimer > state.moveInterval) {
        state.moveTimer = 0;
        moveSnake();
    }

    // Smoothly interpolate render positions towards grid positions
    state.snake.forEach(seg => {
        seg.dx += (seg.x * TILE_SIZE - seg.dx) * 0.4;
        seg.dy += (seg.y * TILE_SIZE - seg.dy) * 0.4;
    });

    updateParticles();
}

function moveSnake() {
    state.dir = state.nextDir;
    const head = state.snake[0];
    const newHead = {
        x: head.x + state.dir.x,
        y: head.y + state.dir.y,
        dx: head.dx + state.dir.x * TILE_SIZE * 0.5, // Predict movement for smoothness
        dy: head.dy + state.dir.y * TILE_SIZE * 0.5,
        scale: 1.3 // Pulse effect on move
    };

    // Animate head scale back to normal
    gsap.to(newHead, { scale: 1, duration: 0.3 });

    // Wall Collision
    if (newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE) {
        gameOver();
        return;
    }

    // Self Collision
    if (state.snake.some(s => s.x === newHead.x && s.y === newHead.y)) {
        gameOver();
        return;
    }

    state.snake.unshift(newHead);

    // Check Food
    if (newHead.x === state.food.x && newHead.y === state.food.y) {
        eatFood();
    } else {
        state.snake.pop();
    }
}

function eatFood() {
    state.score += 10;
    state.itemsToNextSeason--;

    // 1. UI Score Bounce
    const scoreEl = document.getElementById('score-display');
    scoreEl.innerText = state.score;
    gsap.fromTo(scoreEl, { scale: 1.5, color: '#ffff00' }, { scale: 1, color: '#5c3618', duration: 0.5 });

    // 2. Particle Explosion
    createExplosion(state.food.x, state.food.y, CROPS[state.food.typeIdx].color);

    // 3. Screen Flash (Subtle)
    const flash = document.getElementById('flash-overlay');
    gsap.fromTo(flash, { opacity: 0.2 }, { opacity: 0, duration: 0.2 });

    // 4. Season Change Check
    if (state.itemsToNextSeason <= 0) {
        advanceSeason();
    }

    spawnFood();
}

function advanceSeason() {
    state.seasonIdx = (state.seasonIdx + 1) % 4;
    state.itemsToNextSeason = 5; // Reset counter
    updateUI();

    // Full screen color transition handled by CSS/Canvas draw logic automatically
    const currentSeason = SEASONS_INFO[state.seasonIdx];
    // Maybe spawn a lot of environmental particles?
    for(let i=0; i<20; i++) {
        state.particles.push({
            x: Math.random() * BASE_RESOLUTION,
            y: -20,
            vx: (Math.random() - 0.5) * 2,
            vy: Math.random() * 2 + 1,
            life: 150,
            color: COLORS[currentSeason.key].particle,
            size: Math.random() * 4 + 2,
            type: 'ambient'
        });
    }
}

function updateUI() {
    const currentSeason = SEASONS_INFO[state.seasonIdx];
    const seasonEl = document.getElementById('season-display');
    seasonEl.innerText = currentSeason.name;

    const colorMap = {
        'spring': '#69C346',
        'summer': '#E6C658',
        'fall': '#D98636',
        'winter': '#a8d1e3'
    };

    gsap.to(seasonEl, { color: colorMap[currentSeason.key], duration: 1 });
}

function createExplosion(gx, gy, color) {
    const cx = gx * TILE_SIZE + TILE_SIZE/2;
    const cy = gy * TILE_SIZE + TILE_SIZE/2;

    for(let i=0; i<12; i++) {
        const angle = (Math.PI * 2 / 12) * i;
        const speed = Math.random() * 3 + 2;
        state.particles.push({
            x: cx,
            y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 40,
            color: color,
            size: Math.random() * 6 + 4,
            type: 'burst'
        });
    }
}

function updateParticles() {
    for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;

        if (p.type === 'burst') {
            p.size *= 0.92; // Shrink
            p.vy += 0.2; // Gravity
        } else {
            // Ambient float
            p.x += Math.sin(state.gameTime + i) * 0.5;
        }

        if (p.life <= 0 || p.size < 0.5) state.particles.splice(i, 1);
    }
}

function gameOver() {
    state.isPlaying = false;
    document.getElementById('final-score').innerText = state.score;

    if (state.score > state.highScore) {
        state.highScore = state.score;
        localStorage.setItem('svs_highscore', state.highScore);
    }
    document.getElementById('best-score').innerText = state.highScore;

    const el = document.getElementById('game-over-screen');
    el.style.display = 'flex';
    el.style.pointerEvents = 'auto';
    gsap.to(el, { opacity: 1, duration: 0.5 });
    gsap.to('#go-panel', { scale: 1, duration: 0.5, ease: "back.out(1.7)" });
}

// --- Rendering ---
function draw() {
    const currentSeason = SEASONS_INFO[state.seasonIdx];
    const theme = COLORS[currentSeason.key];

    // Clear
    ctx.fillStyle = theme.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Checkerboard Pattern (Subtle)
    ctx.fillStyle = theme.light;
    for(let y=0; y<GRID_SIZE; y++) {
        for(let x=0; x<GRID_SIZE; x++) {
            if ((x+y)%2 === 0) {
                ctx.globalAlpha = 0.1;
                ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.globalAlpha = 1.0;
            }
        }
    }

    // Draw Food (with Glow)
    if (state.food) {
        const crop = CROPS[state.food.typeIdx];
        const fx = state.food.x * TILE_SIZE + TILE_SIZE/2;
        const fy = state.food.y * TILE_SIZE + TILE_SIZE/2;
        const scale = state.food.scale * TILE_SIZE;

        ctx.save();
        ctx.translate(fx, fy);

        // Glow behind food
        ctx.shadowBlur = 20;
        ctx.shadowColor = crop.color;

        // Bounce animation
        const bounce = Math.sin(state.gameTime * 5) * 3;
        ctx.translate(0, bounce);

        // Draw simple crop shape based on type
        drawPixelIcon(ctx, crop.type, crop.color, crop.leaf, scale);

        ctx.restore();
    }

    // Draw Snake
    // Draw connections first? No, just draw circles/rounded rects for cuteness
    state.snake.forEach((seg, i) => {
        const cx = seg.dx + TILE_SIZE/2;
        const cy = seg.dy + TILE_SIZE/2;
        const size = TILE_SIZE * 0.9 * seg.scale;

        ctx.save();
        ctx.translate(cx, cy);

        if (i === 0) {
            // Head
            ctx.fillStyle = COLORS.snake.head;
            ctx.shadowBlur = 15;
            ctx.shadowColor = COLORS.snake.head;

            // Slight squish based on direction
            // Not implemented for simplicity, just scale
        } else {
            // Body
            ctx.fillStyle = COLORS.snake.body;
            // Alternate colors slightly?
            if (i % 2 === 0) ctx.fillStyle = '#7eb830';
        }

        // Draw rounded body
        ctx.beginPath();
        ctx.arc(0, 0, size/2, 0, Math.PI*2);
        ctx.fill();

        // Head Details
        if (i === 0) {
            // Eyes
            ctx.fillStyle = '#1a1a1a';
            const eyeOffX = state.dir.x * 4;
            const eyeOffY = state.dir.y * 4;

            // Blink logic
            const blink = Math.sin(state.gameTime * 3) > 0.95;

            if (blink) {
                ctx.fillRect(-8 + eyeOffX, -2 + eyeOffY, 6, 2);
                ctx.fillRect(2 + eyeOffX, -2 + eyeOffY, 6, 2);
            } else {
                ctx.beginPath();
                ctx.arc(-5 + eyeOffX, -2 + eyeOffY, 3, 0, Math.PI*2);
                ctx.arc(5 + eyeOffX, -2 + eyeOffY, 3, 0, Math.PI*2);
                ctx.fill();
            }

            // Blush
            ctx.fillStyle = COLORS.snake.blush;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(-8 + eyeOffX, 5 + eyeOffY, 3, 0, Math.PI*2);
            ctx.arc(8 + eyeOffX, 5 + eyeOffY, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;

            // Leaf Antenna
            ctx.fillStyle = '#69C346';
            ctx.beginPath();
            ctx.ellipse(0, -12, 4, 8, Math.PI/4, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
    });

    // Draw Particles
    state.particles.forEach(p => {
        ctx.globalAlpha = Math.min(1, p.life / 20);
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    ctx.globalAlpha = 1.0;
}

// Helper to draw procedural pixel art for crops
function drawPixelIcon(ctx, type, mainColor, leafColor, size) {
    const s = size / 20; // Scale factor assuming 20px base

    if (type === 'parsnip') {
        ctx.fillStyle = mainColor; // Body
        ctx.beginPath(); ctx.moveTo(-5*s, -5*s); ctx.lineTo(5*s, -5*s); ctx.lineTo(0, 10*s); ctx.fill();
        ctx.fillStyle = leafColor; // Leaf
        ctx.fillRect(-2*s, -10*s, 4*s, 6*s);
    }
    else if (type === 'strawberry') {
        ctx.fillStyle = mainColor;
        ctx.beginPath(); ctx.arc(0, 2*s, 6*s, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = leafColor;
        ctx.beginPath(); ctx.moveTo(-5*s, -4*s); ctx.lineTo(5*s, -4*s); ctx.lineTo(0, 2*s); ctx.fill();
        // Seeds
        ctx.fillStyle = '#ffcccc';
        ctx.fillRect(-2*s, 2*s, 1*s, 1*s); ctx.fillRect(2*s, 0, 1*s, 1*s);
    }
    else if (type === 'pumpkin') {
        ctx.fillStyle = mainColor;
        ctx.beginPath(); ctx.ellipse(0, 2*s, 8*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = leafColor;
        ctx.fillRect(-1*s, -8*s, 2*s, 4*s);
    }
    else if (type === 'crystal') {
        ctx.fillStyle = mainColor;
        ctx.rotate(Math.PI/4);
        ctx.fillRect(-5*s, -5*s, 10*s, 10*s);
        ctx.fillStyle = 'white';
        ctx.globalAlpha = 0.5;
        ctx.fillRect(-3*s, -3*s, 3*s, 3*s); // Shine
        ctx.globalAlpha = 1.0;
    }
}

function gameLoop(timestamp) {
    const dt = timestamp - state.lastTime;
    state.lastTime = timestamp;

    if (state.isPlaying) {
        update(dt);
    }

    draw();

    // Ambient Particles Generation (always running)
    if (Math.random() < 0.05) {
        const currentSeason = SEASONS_INFO[state.seasonIdx];
        state.particles.push({
            x: Math.random() * BASE_RESOLUTION,
            y: -10,
            vx: (Math.random() - 0.5),
            vy: Math.random() * 1 + 0.5,
            life: 300,
            color: COLORS[currentSeason.key].particle,
            size: Math.random() * 3 + 1,
            type: 'ambient'
        });
    }

    requestAnimationFrame(gameLoop);
}

// --- Initialization ---
document.getElementById('start-btn').addEventListener('click', initGame);
document.getElementById('restart-btn').addEventListener('click', initGame);

// Initial Draw
resize();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>